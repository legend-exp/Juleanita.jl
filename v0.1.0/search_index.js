var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Juleanita","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Juleanita]","category":"page"},{"location":"reference/#Juleanita.electron_charge","page":"Reference","title":"Juleanita.electron_charge","text":"charge of electron in Coulomb\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Juleanita.DAQ_ADC_to_V-Tuple{Real, Real, Int64}","page":"Reference","title":"Juleanita.DAQ_ADC_to_V","text":"DAQ_ADC_to_V(ADC::Real, dynamicrange_V::Real, bits::Int)\n\nConvert ADC-code from digitizer into voltage. The ADC-code is assumed to be in the range.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.GeBandgap-Tuple{Real}","page":"Reference","title":"Juleanita.GeBandgap","text":"GeBandgap(T::Real) bandgap energy (eV) of germanium as a function of temperature (K)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.GeEnergyer_eholePair-Tuple{Real}","page":"Reference","title":"Juleanita.GeEnergyer_eholePair","text":"GeEnergyper_eholePair(T::Real) energy (eV) required to create an electron-hole pair in germanium as a function of temperature (K)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.Ge_NumberChargeCarrier-Tuple{Real, Real}","page":"Reference","title":"Juleanita.Ge_NumberChargeCarrier","text":"Ge_NumberChargeCarrier(E::Real, T::Real) number of charge carriers created by an energy E (eV) in germanium at temperature T (K)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita._is_valid_datestr-Tuple{AbstractString}","page":"Reference","title":"Juleanita._is_valid_datestr","text":"_is_valid_datestr(timestr_file::String; timezone::String = \"PT\")\n\ncheck if the time string in the filename is a valid date string\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.apply_qc-Tuple{Union{PropDicts.PropDict, TypedTables.Table}, PropDicts.PropDict}","page":"Reference","title":"Juleanita.apply_qc","text":"quality cuts based on dsp parameters\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.csv_to_lh5-Tuple{LegendDataManagement.LegendData, LegendDataManagement.DataPeriod, LegendDataManagement.DataRun, Union{Symbol, LegendDataManagement.DataCategory}, LegendDataManagement.ChannelId, String}","page":"Reference","title":"Juleanita.csv_to_lh5","text":"csvtolh5(data::LegendData, period::DataPeriod, run::DataRun, category::DataCategoryLike, channel::ChannelId, csv_folder::String; heading::Int = 17, nwvfmax::Union{Int, Float64, Vector{Int64}} = NaN, nChannels::Int = 2,          ti::ClosedInterval{<:Quantity} = 0.0u\"µs\".. 550.0u\"µs\")\n\nconverts csv files from oscilloscope to lh5 files\nformat of csv file matches the one from an oscilloscope...might be different for other systems\nsaves the lh5 files in the raw tier defined in \"LEGENDDATACONFIG\"\n\nINPUTS:\n\ndata::LegendData LegendData object. You need \"LEGEND_DATA_CONFIG\" to construct this. this will define later where .lh5 files are saved\nperiod::DataPeriod data period that you want to assign your data to \nrun::DataRun data run that you want to assign your data to \ncategory::DataCategoryLike data category that you want to assign your data to\nchannel::ChannelId channel id that you want to assign your data to\ncsv_folder::String folder where the csv files are located\ncsv_heading::Int number of lines to skip in csv file\nnwvfmax::Union{Int, Float64, Vector{Int64}} number of waveforms to read OR vector of waveforms indices to read\nnChannels::Int number of channels in csv files to read (supports only 1 or 2)\nti::ClosedInterval{<:Quantity} time interval to truncate the waveforms to\nwpf::Int waveforms per files –> number of waveforms to write per .lh5 file\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.filteropt_rt_optimization_blnoise","page":"Reference","title":"Juleanita.filteropt_rt_optimization_blnoise","text":"filteropt_rt_optimization_blnoise(filter_type::Symbol, wvfs::ArrayOfRDWaveforms, dsp_config::DSPConfig, τ_pz::Quantity{T}; ft::Quantity{T}= 0.0u\"µs\", τ_cusp::Quantity{<:AbstractFloat} = 10000000.0u\"µs\", τ_zac::Quantity{<:AbstractFloat} = 10000000.0u\"µs\" ) where T<:Real\nfilteropt_rt_optimization_blnoise(filter_type::Symbol, wvfs::ArrayOfRDWaveforms, dsp_config::DSPConfig; kwargs... )\n\nDSP filter optimization to find best rise-time (for a given flat-top time) to minimize ENC noise. This is an alternative way to calculate the enc noise compared to dsp_trap_rt_optimization. Strategy:      filteroptrtoptimizationblnoise(filtertype::Symbol, wvfs::ArrayOfRDWaveforms, dspconfig::DSPConfig, τpz::Quantity{T}; ft::Quantity{T}= 0.0u\"µs\", τcusp::Quantity{<:AbstractFloat} = 10000000.0u\"µs\", τzac::Quantity{<:AbstractFloat} = 10000000.0u\"µs\" ) where T<:Real\n\nShift waveforms to have a common baseline, and deconvolute them with the pole-zero correction (in case τ_pz > 0.0u\"µs\" )\nFilter waveforms with given rise-time and flat-top time\nBuild histogram out of all samples in baseline from all waveforms. Remove bins at the beginning and end of the waveform to avoid edge effects.\nCalculate the RMS of the baseline noise –> ENC noise\n\nInputs:\n\nfilter_type::Symbol: filter type (:trap or :cusp)\nwvfs::ArrayOfRDWaveforms: raw waveforms to be filtered\ndsp_config::DSPConfig: DSP configuration object containing relevant parameters: ft, grid_rt, bl_window, flt_length_cusp,  flt_length_zac\nτ_pz::Quantity{T}: pole-zero decay time. If τ_pz = 0.0u\"µs\" (or none given), no pole-zero correction is applied.\n\nOptional inputs:\n\nft::Quantity{T}: fixed flat-top time for optimization\nτ_cusp::Quantity{<:AbstractFloat}: cusp decay time; only relevant for cusp filter\nτ_zac::Quantity{<:AbstractFloat}: cusp decay time; only relevant for zac filter\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.fit_linearity-Union{Tuple{T}, Tuple{Int64, AbstractVector{<:Measurements.Measurement{<:T}}, AbstractVector{<:Measurements.Measurement{<:T}}}} where T<:Real","page":"Reference","title":"Juleanita.fit_linearity","text":"fit_linearity(pol_order::Int, µ::AbstractVector{<:Union{Real,Measurement{<:Real}}}, peaks::AbstractVector{<:Union{Real,Measurement{<:Real}}}; pull_t::Vector{<:NamedTuple}=fill(NamedTuple(), pol_order+1), v_init::Vector = [], uncertainty::Bool=true )\n\nFit the calibration lines with polynomial function of polorder order     polorder == 1 -> linear function     pol_order == 2 -> quadratic function\n\nReturns\n\n* `result`: NamedTuple with the following fields\n    * `par`: best-fit parameters\n    * `gof`: godness of fit\n* `report`:\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.process_ctc-Tuple{LegendDataManagement.LegendData, LegendDataManagement.DataPeriod, LegendDataManagement.DataRun, Union{Symbol, LegendDataManagement.DataCategory}, LegendDataManagement.ChannelId, PropDicts.PropDict, PropDicts.PropDict}","page":"Reference","title":"Juleanita.process_ctc","text":"process_ctc(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, ecal_config::PropDict, ctc_config::PropDict;\n            energy_types::Vector{Symbol} = Symbol.(ctc_config.energy_types), reprocess::Bool = false)\nprocess_ctc(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; kwargs...)\n\nCalculate charge-trapping correction: by looking at correlation between drift time and energy. Save correction function to rpars.  Inputs:\n\ndata::LegendData: LegendData object\nperiod::DataPeriod: data period\nrun::DataRun: data run\ncategory::Union{Symbol, DataCategory}: data category, e.g. :cal\nchannel::ChannelId: channel id\necal_config::PropDict: energy calibration configuration. If not specified use default from metadata\nctc_config::PropDict: charge-trapping correction configuration. If not specified use default from metadata\n\nOptional:\n\nenergy_types::Vector{Symbol}: energy types to process\nreprocess::Bool: reprocess the files or not\njuleana_logo::Bool: add juleana logo to plots\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.process_decaytime","page":"Reference","title":"Juleanita.process_decaytime","text":"process_decaytime(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, min_τ::Quantity{T}, max_τ::Quantity{T}, nbins::Int, rel_cut_fit::Real, peak::Symbol, bl_window::ClosedInterval{<:Unitful.Time{<:T}}, tail_window::ClosedInterval{<:Unitful.Time{<:T}}; reprocess::Bool = false) where T <: Real\n\nprocess_decaytime(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, pz_config::PropDict, bl_window::ClosedInterval{<:Unitful.Time{<:T}}, tail_window::ClosedInterval{<:Unitful.Time{<:T}}; kwargs...) where T <: Real\n\nprocess_decaytime(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, pz_config::PropDict, dsp_config::DSPConfig; kwargs...)\n\nprocess_decaytime(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; kwargs...)\n\nGoal: calculate decay time used for pole-zero correction Inputs:\n\ndata::LegendData: LegendData object\nperiod::DataPeriod: data period\nrun::DataRun: data run\ncategory::Union{Symbol, DataCategory}: data category, e.g. :cal\nchannel::ChannelId: channel id\nmin_τ::Quantity{T}: minimum decay time\nmax_τ::Quantity{T}: maximum decay time\nnbins::Int: number of bins for histogram\nrel_cut_fit::Real: relative cut for truncated gauss\npeak::Symbol: peak to use for decay time calculation. Can also be :all to use all :raw instead of :jlpeaks tier\nbl_window::ClosedInterval{<:Unitful.Time{<:T}}: baseline window\ntail_window::ClosedInterval{<:Unitful.Time{<:T}}: tail window\n\nOptional:\n\nreprocess::Bool: reprocess the files or not\njuleana_logo::Bool: add juleana logo to plots\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.process_dsp","page":"Reference","title":"Juleanita.process_dsp","text":"process_dsp(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, dsp_config::DSPConfig, τ_pz::Quantity{<:Real}, pars_filter::PropDict; reprocess::Bool = false )  \nprocess_dsp(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId ; kwargs... )\n\nrun the DSP processing for all raw files in the given period, run, category and channel.\nbased on \"simple_dsp\" function\nsave the results in the jldsp tier\nif reprocess is false, it will skip the files that are already processed\n\nINPUTS:     - data::LegendData LegendData object. You need \"LEGEND_DATA_CONFIG\" to construct this, e.g. l200 = LegendData(:l200)     - period::DataPeriod data period, e.g. DataPeriod(1)     - run::DataRun data run, e.g. DataRun(1)     - category::Symbol data category, e.g. DataCategory(:cal)     - channel::ChannelId channel id, e.g. ChannelId(1) (depending on your data!)     - dsp_config::DSPConfig DSP configuration object. If not specified will take default from metadata     - τ_pz::Quantity{<:Real} decay time used for pole-zero correction. If not specified will take from rpars.pz     - pars_filter::PropDict optimized filter parameters used in DSP. If not specified will take from rpars.fltopt KWARGS:     - reprocess::Bool reprocess the files or not OUTPUTS:     - save the DSP results in the jldsp tier     - print the progress     - print the completion message\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.process_energy_calibration","page":"Reference","title":"Juleanita.process_energy_calibration","text":"process_energy_calibration(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, source::Symbol; reprocess::Bool = true, ecal_config::PropDict = data.metadata.config.energy.energy_config.default, e_types::Vector{<:Symbol} = [:e_trap, :e_cusp, :e_zac])\n\nperform energy calibration: take uncalibration energy values from dsp files and calibrate them using calibration sources INPUTS:\n\ndata::LegendData: LegendData object\nperiod::DataPeriod: data period\nrun::DataRun: data run\ncategory::Union{Symbol, DataCategory}: data category, e.g. :cal\nchannel::ChannelId: channel id\nsource::Symbol: calibration source. :th228 or :co60 are supported at the moment\n\nOPTIONAL:\n\nreprocess::Bool: reprocess the files or not\necal_config::PropDict: energy calibration configuration. if not specified, it will take the default from metadata\netypes::Vector{<:Symbol}: energy types to calibrate. default is [:etrap, :ecusp, :ezac]\n\nOUTPUT:\n\nsave the calibration parameters as json files to disk (in generated/par/rpars/ecal/...) \nsave the calibration plots to disk (in generated/jlplt/rplt/...)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.process_filteropt","page":"Reference","title":"Juleanita.process_filteropt","text":"process_filteropt(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, dsp_config::DSPConfig, τ_pz::Quantity{T}, peak::Symbol; rt_opt_mode::Symbol = :blnoise, reprocess::Bool = false, filter_types::Vector{Symbol} = [:trap, cusp])\nprocess_filteropt(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; kwargs...)\n\nFilter optimization for filter_types\n\nload waveforms from peakfile, shift baseline and pole-zero \noptimize rise-time for minimum baseline noise after filtering\noptimize flat-top time for FWHM of peak\nsave results to disk\nsanity plots for rise-time and flat-top time optimization\n\nInputs: \n\ndata::LegendData: LegendData object\nperiod::DataPeriod: data period\nrun::DataRun: data run\ncategory::Union{Symbol, DataCategory}: data category, e.g. :cal\nchannel::ChannelId: channel id\n\nOptional:\n\ndsp_config::DSPConfig: DSP configuration object. If not specified will take default from metadata\nτ_pz::Quantity{T}: pole-zero decay time.  If not specified will take default from metadata\npeak::Symbol: peak to optimize for (needs existing peakfile!). If not specified will take default from metadata\nrt_opt_mode::Symbol: mode for rise-time optimization (:blnoise or :pickoff) –> two different strategies for optimization\nreprocess::Bool: reprocess the files or not\nfilter_types::Vector{Symbol}: filter types to optimize for\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.process_hit-Tuple{LegendDataManagement.LegendData, LegendDataManagement.DataPeriod, LegendDataManagement.DataRun, Union{Symbol, LegendDataManagement.DataCategory}, LegendDataManagement.ChannelId}","page":"Reference","title":"Juleanita.process_hit","text":"processing_hit(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; reprocess::Bool = false, e_types::Vector{<:Symbol} = [:e_trap, :e_cusp, :e_zac])\n\nrun the hit processing for all dsp files in the given period, run, category and channel.\napply energy calibration to the dsp energy estimator and save the results in the jlhit tier \nno PSD at the moment, will be added in future \nif reprocess is false, it will skip the files that are already processed\n\nINPUTS:\n\ndata::LegendData LegendData object\nperiod::DataPeriod data period\nrun::DataRun data run\ncategory::Union{Symbol, DataCategory} data category, e.g. :cal\nchannel::ChannelId channel id\nreprocess::Bool reprocess the files or not\ne_types::Vector{<:Symbol} energy types to process. default is [:etrap, :ecusp, :e_zac]\n\nOUTPUTS:\n\nsave the hit results in the jlhit tier\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.process_peak_split","page":"Reference","title":"Juleanita.process_peak_split","text":"process_peak_split(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, ecal_config::PropDict, dsp_config::DSPConfig, qc_config::PropDict; reprocess::Bool = false)\nprocess_peak_split(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; kwargs...)\n\nCreate peak files containting only waveforms from peaks in the calibration spectrum.\n\nRead raw data\nFind peaks in the calibration spectrum using rough energy estimate data_fk.daqenergy\nDo simple DSP for peaks only \napply quality cuts based on simple DSP\nSave waveforms after QC to peak files\n\ninputs:\n\ndata: LegendData object\nperiod: DataPeriod object\nrun: DataRun object\ncategory: Symbol or DataCategory object, e.g. :cal for calibration \nchannel: ChannelId for germanium detector \necal_config: PropDict, energy calibration configuration\ndsp_config: DSPConfig, DSP configuration\nqc_config: PropDict, quality cut configuration\n\nkeyword arguments:\n\nreprocess: Bool, default is false\n\nOutput:\n\nh_uncals histograms of peaksearch\npeakpos \n\nAlso, peak files containting only waveforms from peaks in the calibration spectrum are saved to jlpeaks folder.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.process_peakfits","page":"Reference","title":"Juleanita.process_peakfits","text":"progress_peakfits(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; reprocess::Bool = true, e_types::Vector{<:Symbol} = [:e_trap, :e_cusp, :e_zac], juleana_logo::Bool = false)\nProcess the peak fits for the benchtest data.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.process_qualitycuts","page":"Reference","title":"Juleanita.process_qualitycuts","text":"process_qualitycuts(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; reprocess::Bool = false, qc_config::PropDict = data.metadata.config.qc.qc_config.default)\n\napply quality cuts based on dsp parameters  inputs:      data: LegendData object     period: DataPeriod object     run: DataRun object     category: Symbol or DataCategory object     channel: ChannelId object     reprocess: Bool, default false     qcconfig: PropDict, default data.metadata.config.qc.qcconfig.default\n\n\n\n\n\n","category":"function"},{"location":"reference/#Juleanita.pulser_ADC_to_electrons-Tuple{Real, Real}","page":"Reference","title":"Juleanita.pulser_ADC_to_electrons","text":"pulser_ADC_to_electrons(ADC::Real, C_pulser::Real; bits::Int = 14, dynamicrange_V::Real = 2.0, gain::Real = 1.0)\n\nConvert ADC-code from pulser into injected charge in pulserADCto_electrons\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.pulser_ADC_to_keV-Tuple{Real, Real}","page":"Reference","title":"Juleanita.pulser_ADC_to_keV","text":"pulser_ADC_to_keV(ADC::Real, C_pulser::Real; bits::Int = 14, dynamicrange_V::Real = 2.0, gain::Real = 1.0)\n\nConvert ADC-code from pulser into injected energy in keV.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.read_csv_metadata-Tuple{String}","page":"Reference","title":"Juleanita.read_csv_metadata","text":"read_csv_metadata(filepath::String; heading::Int = 17, nChannels::Int = 2, timezone = \"PT\")\n\nread metadata from a csv file (as taken from oscilloscope) input:\n\nfilepath::String: file name\nheading::Int: number of lines (beginning at top) in csv file contain metadata \nnChannels::Int: number of channels in csv file\ntimezone::String: timezone to which the timekey in filename refers (standard is PT = Pacific Time –> Berkeley)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.read_folder_csv_oscilloscope-Tuple{String}","page":"Reference","title":"Juleanita.read_folder_csv_oscilloscope","text":"read_folder_csv_oscilloscope(csv_folder::String; heading::Int = 17, nwvfmax::Union{Int, Float64, Vector{Int64}} = NaN, nChannels::Int = 2)\n\nread folder with csv files from oscilloscope input:\n\ncsv_folder::String: absolute csv folder path\nheading::Int: number of lines to skip\nnwvfmax::Union{Int, Float64, Vector{Int64}}: number of waveforms to read OR vector of waveforms indices to read\nnChannels::Int: number of channels in csv files to read (1 or 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.simple_dsp-Union{Tuple{T}, Tuple{Q}, Tuple{Q, LegendDSP.DSPConfig}} where {Q<:TypedTables.Table, T<:Real}","page":"Reference","title":"Juleanita.simple_dsp","text":"simple_dsp(data::Q, dsp_config::DSPConfig; τ_pz::Quantity{T} = 0.0u\"µs\", pars_filter::PropDict) where {Q <: Table, T<:Real}\n\ndsp routine which calculates all relevant parameters for the waveform analysis\n\ndata::Q: input data, e.g. raw file, peakfile \ndsp_config::DSPConfig: DSP configuration object\nτ_pz::Quantity{T}: pole-zero decay time. If τ_pz = 0.0u\"µs\" (or none given), no pole-zero correction is applied.\npars_filter::PropDict: filter parameters for the different filter types. Use PropDict() to get default values from config.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.simple_dsp_pulser-Union{Tuple{T}, Tuple{Q}, Tuple{Q, LegendDSP.DSPConfig}} where {Q<:TypedTables.Table, T<:Real}","page":"Reference","title":"Juleanita.simple_dsp_pulser","text":"simple_dsp_pulser(data::Q, dsp_config::DSPConfig; τ_pz::Quantity{T} = 0.0u\"µs\", pars_filter::PropDict) where {Q <: Table, T<:Real}\n\nminimal version of simple_dsp for pulser channel \n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.simple_dsp_qc-Union{Tuple{T}, Tuple{Q}, Tuple{Q, LegendDSP.DSPConfig}} where {Q<:TypedTables.Table, T<:Real}","page":"Reference","title":"Juleanita.simple_dsp_qc","text":"minimal version of simple_dsp  used to calculate quality cuts with peakfiles \n\n\n\n\n\n","category":"method"},{"location":"reference/#Juleanita.sktutek_csv_to_lh5","page":"Reference","title":"Juleanita.sktutek_csv_to_lh5","text":"skutek_csv_to_lh5(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId, csv_folder::String; timestep::Quantity = 0.01u\"µs\")\n skutek_csv_to_lh5(data::LegendData, period::DataPeriod, run::DataRun, category::Union{Symbol, DataCategory}, channel::ChannelId; kwargs...)\n\nconvert csv files from Skutek digitizer \"FemtoDAQ Vireo\" to lh5 files\n\nformat of csv file matches the one of  Skutek digitizer \"FemtoDAQ Vireo ...might be different for other systems\n\ninputs:\n\ndata::LegendData LegendData object. You need \"LEGEND_DATA_CONFIG\" to construct this. this will define later where .lh5 files are saved\nperiod::DataPeriod data period that you want to assign your data to\nrun::DataRun data run that you want to assign your data to\ncategory::DataCategoryLike data category that you want to assign your data to\nchannel::ChannelId channel id that you want to assign your data to\ncsv_folder::String folder where the csv files are located (optinal). if not defined use the default folder\n\nkwargs\n\ntimestep::Quantity time step of the waveforms.  default is 0.01µs –> 100 MHz sampling. \nchmode::Symbol = :diff: mode of the digitizer. :diff for differential mode, :pulser for pulser mode (work in progress)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Juleanita","category":"page"},{"location":"#Juleanita","page":"Home","title":"Juleanita","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Juleanita. Juleanita is a meta-package for the Julia software stack to analyse teststand data for the LEGEND experiment.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/LisaSchlueter/Juleanita.jl.git","category":"page"}]
}
